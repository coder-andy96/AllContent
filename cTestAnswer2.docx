二、单选题
下面代码片断，哪个没有安全问题： C
①void main(int argc, char *argv[])
{
    char dst[128];
    if (argc > 1)
    {
        strcpy(dst, argv[1]);
    }
    /*…*/
}

②void  foo ()
{
char dst[11];
    char src[] = "0123456789";
    char *tmp = NULL;
    memset(dst,'@',sizeof(dst));
    memcpy(dst,src, strlen(src));
    printf("src: %s \r\n", src);
    tmp = dst;
    do
   {
      putchar(*tmp);
   }while (*tmp++);
return;
}
③void  foo()
{
    char *error_msg = "Resource not available to user.";
    int error_type = 3;
    /* ...do something... */
    printf("Error (type %s): %d\n", error_type, error_msg);
}
④int * foo(int x)
{
    int i;
    int *y;
    if(0 < x < MAX_SIZE)
    {
        y = (int *)malloc( x * sizeof(int));
        if (y == NULL)
           return ERROR;
    }
    else
    {
       return ERROR;
    }
 for(i = 0; i < x; i++)
    {
       y[i] = i;
    }
    return y;
}
A. ①

B. ②

C. ④
D. ③
12. 关于c++类和对象安全，下列说错误的是: A
A. 基类析构函数可以为非虚函数
B. 禁止切分多态的类对象
C. 禁止在类的公共接口中返回类的私有数据地址
D. 避免出现delete this操作
13. 下面针对malloc函数申请动态内存的说法中错误的是： D
A. 使用 0 字节长度去申请内存的行为是没有定义的，在引用内存申请函数返回的地址时会引发不可预知或不能立即发现的问题
B. 动态申请操作一般应和释放操作配合使用，防止内存泄露
C. 使用负数长度去申请内存，负数会被当成一个很大的无符号整数，从而可能导致因申请内存过大而出现失败
D. 动态申请内存被释放2次，一般不会造成安全问题
14. 下列哪种方式产生的随机数是不安全、容易被预测的： A
A. C99的rand()
B. Unix/Linux下读取/dev/random文件
C. Windows使用随机数生成函数CryptGenRandom()
15.以下哪种属于可信输入：   A
A. 满足“白名单”要求的输入
B. 数据库读取的数据
C. 用户键盘输入
D. 配置文件输入
16.以下关于ASLR说法不正确的是 B
A. ASLR会随机地安排进程的关键数据区域的地址空间位置
B. linux下/proc/sys/kernel/randomize_va_space为0开启该功能
C. 是涉及防止缓冲区溢出攻击的计算机安全技术
D. Linux、FreeBSD、Windows等主流操作系统都已采用了该技术
17. 以下哪个选项是典型的路径遍历漏洞特征：B
A. ; cat /etc/passwd;
B. ../../../etc/passwd
C. <ScRiPt>console.log("what is /etc/passwd")</ScRiPt>
D. select 1,2,3 into outfile /var/www/public.txt;
18. 下列代码片段中，至多有一个存在不安全行为，请指出你认为存在不安全行为的代码： C
①text 保证为空字符结尾的字符串
int rot13(char* text)
{
  unsigned int length = strlen(text);
  for (unsigned int i = 0; i < length; i++) {
    if (text[i] >= 'a' && text[i] <= 'z') {
      text[i] = (text[i] - 'a' + 13) % 26 + 'a';
    } else if (text[i] >= 'A' && text[i] <= 'Z') {
      text[i] = (text[i] - 'A' + 13) % 26 + 'A';
    }
  }
  return 0;
}
②struct ping_request_t {
  unsigned int expected_response_size; // 用户输入
};
void handle_ping(struct ping_request_t* req)
{
  if (req->expected_response_size < =4 | | req->expected_response_size > 256) {
    return;
  }
  char* resp = (char*) calloc(req->expected_request_size);
  /* validate resp not NULL */
  strncpy(resp, "PONG", 4);
  send_response(resp, req->expected_request_size); // 将resp指向的req->expected_request_size字节发送回给用户
  return;
}
③int scramble_signal(const unsigned short* wave, unsigned int length)
{
  static unsigned char buffer[4096];
  if (length > 2048) {
    return 1;
  }
  memcpy(buffer, wave, sizeof(wave) * length);
  /* … */
  return 0;
④以上三个代码片段中均不存在不安全行为
A. ①
B. ④
C. ③
D. ②
19. 下列代码片段中，data 所指向的缓冲区内容来自网络且未经任何验证，其长度为length字节，以下代码存在不安全行为的根源是什么？ B
struct stream_content_t {
  size_t count;
  uint32_t data[0];
};
int handle_stream_content(const uint8_t* data, size_t length)
{
  stream_content_t *stream = (stream_content_t*) data;
  uint32_t *frames =(uint32_t*) malloc(stream->count * sizeof(uint32_t));
  if (length < sizeof(size_t) + stream->count * sizeof(uint32_t)) return 1;
  for (size_t i = 0;i < stream->count;i++) {
    frames[i] = stream->data[i];
    process_frame(i, frames[i]);
  }
  return 0;
}
A. 使用未初始化变量
B. 整数溢出/反转
C. 堆缓冲区溢出
D. 栈溢出
20. 以下代码存在什么安全问题： A
int recvline(int fd, char *buf, int n) {
 int i;
 for (i = 0; i < n; i++) {
   int r = read(fd, &buf[i], 1);
   if (r == -1) {
    break;
   } else if (r == 1 && (buf[i] == '\n'))
    break;
 }
 buf[i] = '\0';
 if (i > 1 && buf[i - 1] == '\r')
   buf[--i] = '\0';
 return i;
}
int main () {
 unsigned int size1;
 size_t size2;
 size1 = 0x50;
 size2 = size1;
 char buf[0x100];
 recvline(0, buf, size2);
 printf(buf);
 return 0;
}
A. 格式化字符串漏洞
B. 条件竞争
C. 缓冲区溢出
D. 类型混淆
31.（单选）关于函数设计，不正确的说法是___c__。
A. 对函数的错误返回码需要全面处理
B. 函数设计的精髓：编写整洁函数，同时把代码有效组织起来。
C. 程序正确性是最重要的，能用的代码即使大量重复也不提炼成函数。
D. 避免函数代码块嵌套过深，新增函数的代码块嵌套不超过4层。
32. 下列关于内存的申请，正确的是：A
A. int *id_sequence; /* Allocate space for an array of three ids. */ id_sequence = (int*) malloc(12); if (id_sequence == NULL) exit(1); /* Populate the id array. */ id_sequence[0] = 13579; id_sequence[1] = 24680; id_sequence[2] = 97531;
B. int i; unsigned int numWidgets; Widget **WidgetList; numWidgets = GetUntrustedSizeValue(); if ((numWidgets == 0) ll (numWidgets > MAX_NUM_WIDGETS)) { ExitError("Incorrect number of widgets requested!"); } WidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *)); printf("WidgetList ptr=%p\n", WidgetList); for(i=0; i<numWidgets; i++) { WidgetList[i] = InitializeWidget(); } WidgetList[numWidgets] = NULL; showWidgets(WidgetList);
C. DataPacket *packet; int numHeaders; PacketHeader *headers; sock=AcceptSocketConnection(); ReadPacket(packet, sock); numHeaders =packet->headers; if (numHeaders > 100) { ExitError("too many headers!"); } headers = malloc(numHeaders * sizeof(PacketHeader); ParsePacketHeaders(packet, headers);
D. img_t table_ptr; /*struct containing img data, 10kB each*/ int num_imgs; ... num_imgs = get_num_imgs(); table_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs); ...
33. （单选）下面说法中正确的是___C__。
A. 程序效率是最重要的。
B. 函数设计时，为了可扩展，可以为不同的功能预留参数，以便后续增加新功能使用。
C. 不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。
D. 废弃代码（没有被调用的函数和变量)不影功能就不需要清除。
34. 下列说法错误的是：C
A. // Method called from servlet to obtain product information public String displayProductSummary(int index) { String productSummary = new String(""); try { String productSummary = getProductSummary(index); } catch (Exception ex) {...} return productSummary; } public String getProductSummary(int index) { return products[index]; } 该代码中index未校验，可能引起数组越界访问。
B. String script = System.getProperty("SCRIPTNAME"); if (script != null) System.exec(script); 该代码可能会引起OS命令注入。
C. String street = "QueenStreet"; Query query = session.createQuery("from Address a where a.street='" + street + "'"); 该代码可能会产生sql注入漏洞。
D. class DirList { public static void main(String[] args) { if (args.length == 0) { System.out.println("No arguments"); System.exit(1); } try { Runtime rt = Runtime.getRuntime(); Process proc = rt.exec("cmd.exe /c dir " + args[0]); // ... } catch (Exception e) { // Handle errors } } } 改代码可能引起命令注入。
35. 需要对指定申请内存大小的整数值进行合法性校验，是因为： 1.使用 0 字节长度去申请内存的行为是没有定义的，在引用内存申请函数返回的地址时会引发不可预知或不能立即发现的问题 2.使用负数长度去申请内存，负数会被当成一个很大的无符号整数，从而导致因申请内存过大而出现失败   C
A. 只有2对
B. 1,3都不对
C. 1,2都对
D. 只有1对
36. 下列哪个场景可以使用rand()产生的随机数：A
A. 随机选取路由
B. 挑战算法中的随机数生成
C. 验证码的随机数生成
37. system()/popen()存在命令注入漏洞的根本原因是：C
A. 没有对入参做长度校验
B. 存在缓冲区溢出漏洞
C. 调用命令解析器来执行入参指定的程序/命令
38. （单选）如下放在头文件a.h中的内容错误的是：A
 
A. ③
B. ②
C. ①
39. （单选）如果a.c包含了头文件a.h，a.h包含了头文件b.h，b.c也包含了b.h，那么当b.h发生改变时，哪些文件将会被重新编译：D
A. a.c和a.h
B. a.h
C. b.c
D. a.c和b.c
40. 关于SQL注入说法错误的是：A
A. 使用存储过程可以有效防止SQL注入。
B. 所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
C. 一个有效防止SQL注入的方法是将存储在数据库中的数据加密。
D. SQL注入可以一般分为平台层注入和代码层注入。
41. 下列哪项代码没有问题的：
A. void host_lookup(char *user_supplied_addr){ struct hostent *hp; in_addr_t *addr; char hostname[64]; in_addr_t inet_addr(const char *cp); /*routine that ensures user_supplied_addr is in the right format for conversion */ validate_addr_form(user_supplied_addr); addr = inet_addr(user_supplied_addr); hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET); strcpy(hostname, hp->h_name); }
B. int main(int argc, char *argv[]) { char *dst = NULL; size_t length = strnlen(argv[1], MAX_LEN); if (argc > 1) { dst = (char *)malloc(length + 1); if(dst != NULL) { strcpy_s(dst, length + 1, argv[1]); } } return 0; }
C. #define BUFSIZE 256 int main(int argc, char **argv) { char buf[BUFSIZE]; strcpy(buf, argv[1]); }
D. enum { ARRAY_SIZE = 32 }; void func(void) { char dst[ARRAY_SIZE + 1] = {0x00}; char src[ARRAY_SIZE + 1] = {0x00}; size_t i = 0; for (i = 0; src[i]!= ‘\0’ && (i < (ARRAY_SIZE + 1)); ++i) { dst[i] = src[i]; } dst[i] = '\0'; }
42. 下述关于格式化函数的说法错误的是：B
A. 应禁止使用用户输入作为格式化字符串的一部分
B. 格式化输出函数的格式化参数和实参个数不匹配不会给程序带来风险
C. 使用格式化函数时，应该为格式化指示符加上精度说明符以防止缓冲区溢出漏洞
D. 格式化输出函数的格式化参数和实参类型必须匹配
43. 下列关于跨站脚本攻击说法正确的是：A
A. XSS通常分为3种类型，即反射型、存储型和Dom Based。
B. 图片等富文本不会造成XSS攻击。
C. 利用安全框架或者任意编码方法就可以完全防御XSS。
D. 通常认为反射型XSS的危害普遍高于存储型。
44. 下列哪个场景可以使用system()/popen()：A
A. 硬编码输入“rm *.log”，删除当前目录下的所有日志文件
B. 删除用户指定的文件
C. 执行带用户输入作为参数的程
45. （单选）以下说法正确的是：C
A. 全局变量可以作为对外的接口，使用方便，编码时尽量使用全局变量作为接口
B. 使用位域时，和普通数据类型做同样的字节序转换后即可解析
C. 严禁使用未经初始化的变量作为右值
D. 局部变量和全局变量的作用域不同，我不需要使用全局变量，所以局部变量我可以随意命名
31．关于c++类和对象安全，下列说错误的是:
 
32. 下列关于内存的申请，正确的是：
下面那些函数是不安全、被禁止使用的： 
33. 下面那些函数是不安全、被禁止使用的：
 
34. 以下哪种属于可信输入：
 
35. 关于文件输入/输出安全的说法错误的是
 
36. （单选）关于文件头注释，哪一项是不必须的？  
 
37. 对于字符串"abcdefghi0"使用多大字符数组进行存储最为合适：
 
38. 阅读以下代码片断，确认该代码片断有那种代码安全漏洞? String rName = request.getParameter("reportName"); File rFile = new File("/usr/local/apfr/reports/" + rName); ... rFile.delete();
 
39. （单选）关于函数命名，不正确的说法是______。
 
40. （单选）以下哪种措施不可以避免内存操作越界
 
41. （单选）下面说法中正确的是__第四个___。
A. 函数设计时，为了可扩展，可以为不同的功能预留参数，以便后续增加新功能使用。
B. 废弃代码（没有被调用的函数和变量)不影功能就不需要清除。
C. 程序效率是最重要的。
D. 不变的值更易于理解/跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。
 
42. （单选）关于程序注释，哪条描述是正确的？
 
43. 下列哪个场景可能导致敏感信息泄露？
 
44. C/C++程序中system()/popen()存在命令注入漏洞的根本原因是：
 
45. 关于资源的描述错误的是：
 
三、多选题
21.对于如下代码，说法正确的是: ACD
void Func(char *user, char *password) 
{
    char input[1000]= {0x0};
    if (fgets(input, sizeof(input) - 1, stdin) == NULL) 
    {
        /* handle error */
    }
    input[sizeof(input)-1] = ’\0’;
    printf(input); 
}
A. 当用户输入input是“%s%s%s%s%s%s%s%s%s”，就可能触发无效指针或未映射的地址，导致程序崩溃
B. 语句fgets(input, sizeof(input) - 1, stdin)可能会对input写溢出
C. 解引用空指针是一种未定义的行为，而最为有效地防止空指针解引用的方法就是在指针使用前做非空校验。
D. 代码的input直接来自用户输入，并作为格式化字符串直接传递给printf(),可能造成格式化漏洞
22. 下列代码片断哪些存在安全风险： ABCD
①unsigned int add(unsigned int a, unsigned int b)
{
    unsigned int sum;
    sum = a + b;
    return sum;
}

②int file_ops(char* file_name)
{
    FILE *fp; 
    fp = fopen(file_name, "w");
    if (fp == NULL) {
        return -1;
    }
 
    /* 其他处理 */
    if (fclose(fp) != 0) {
        return -1;
    }
    if (remove(file_name) != 0) {
        return -1;
    }
    return 0;
}
③int foo(char* str)
{
    size_t len = strlen(str);
    if (len >= MAX_BUF_SIZE - 1) {
        return -1;
    }
    char *buf = (char*)malloc(256);
    if (buf == NULL) {
        return -1;
    }
    strncpy(buf, str, len);
 
   /* 对 buf 的其它处理 */
 
    free(buf);
    buf = NULL;
}
④int  id_gen()
{
 enum {len = 12};
 char id[len]= {0x00};
 int r = 0;
 int num = 0;
 r = rand();
 num = snprintf(id, len, "Session-ID%-d", r); /* 生成 ID */
 /* 其他处理 */
}
A. ②
B. ④
C. ③
D. ①
23. 最小权限原则是要求计算环境中的特定抽象层的每个模块如进程、用户或者计算机程序只能访问当下所必需的信息或者资源。关于最小权限原则的说法，正确的包括: ABC (错选为BC)
A. 如果不能永久地放弃特权，可以尽可能经常地去除程序的特权
B. 只为程序中需要特权的部分授予特权
C. 将特权的有效时间或者可以有效的时间限制到绝对最小
D. 程序运行时可以赋予相关联的进程同等特权，只要结束时记得去除就好
24.下列代码片段中，哪几行存在可能越界读写内存或导致其他代码越界读写内存的代码：  ABCD (错选为AB)
int parse_digits(const char* number)
{
  char source[10];
  strcpy(source, "0123456789");     /* A */
  char* dest = (char*) malloc(strlen(source)); /* B */
  int i;
  for (i = 1; i <= 11; i++) { /* C */
    dest[i] = source[i];
  }
  dest[i] = '\0'; /* D */
  /* deal with number, irrelevant */
}
A. D标记对应处
B. C标记对应处
C. A标记对应处
D. B标记对应处
25.以下代码，可能直接导致的安全问题有：BCD错选为ABCD
int main(int argc, char *argv[]) {
  char cmd[1024];
  sprintf(cmd, “cat %s”, argv[1]);
  return exec(cmd);
}
A. XSS 攻击
B. 命令注入
C. 任意文件泄露
D. 栈溢出
26. 阅读下列代码片段： #define MAX_SIZE 256 int main(int argc, char* argv[]) { char network_ssid[MAX_SIZE]; if (argc < 2) return 1; strcpy(network_ssid, argv[1]); /* do something */ return 0; } 以上程序执行时的命令行参数是用户可控的。众所周知，处理用户输入时使用 strcpy 拷贝用户可控的字符串极易导致缓冲区溢出，下列解决方案中哪一个仍然会造成缓冲区溢出？D错选ABC
A. 在strcpy一行前加入 if (strlen(argv[1]) >= MAX_SIZE) return 1;
B. 将network_ssid的声明修改为 char *network_ssid;，将strcpy一行替换为 network_ssid = strdup(argv[1])，并在函数返回前，释放network_ssid；
C. 将strcpy一行替换为 network_ssid[0] = 0; strncat(network_ssid, argv[1], MAX_SIZE-1);
D. 将strcpy一行替换为 strncpy(network_ssid, argv[1], strlen(argv[1]));
27. 下列关于整数的操作错误的有:（INT32表示32位有符号整数，UINT32表示32位无符号整数，INT8表示8位有符号整数）BCD错选ABCD
①INT32 Func(UINT32 ui1, UINT32 ui2, UINT32 * ret)
{
 if( NULL == ret )
 {
  return ERROR;
 }
 if((UINT_MAX - ui1) < ui2) 
 {
  return ERROR;
 }
 else
 {
  *ret = ui1+ ui2;
 }
 return OK;
}
②INT32 Func(INT32 si1, INT32 si2, INT32 *ret)
{
 if ( NULL == ret )
 {
  return ERROR;
 }
 *ret = si1 * si2;
 return OK;
}
③INT32  Func(UINT32 ui, INT8 *ret)
{
 if( NULL == ret )
 {
  return ERROR;
 }
 *ret = (INT8)ui;
 return (OK);      
}
④#define BUF_SIZE 10
int main(int argc, char* argv[])
{
 int length;
 char buf[BUF_SIZE];
 if (argc != 3)
 {
  return -1;
 }
 length = atoi(argv[1]); 
 if (length < BUF_SIZE) 
 {
  memcpy(buf, argv[2], length); 
  printf("Data copied\n");
 }
 else
 {
  printf("Too many data\n");
 }
A. ④
B. ②
C. ③
D. ①
28. 下列哪些加密算法是符合安全要求的：  ABC
A. RSA 2048
B. AES 256
C. SHA 256
D. DES
29. 下列哪些方式产生的随机数可用于安全用途：BCDE
A. Unix/Linux下读取/dev/urandom文件
B. Unix/Linux下读取/dev/random文件
C. Windows使用随机数生成函数CryptGenRandom()
D. 使用开源组件openssl
E. 使用我司中研封装的iPSI组件
30. 以下说法正确的有： BD
A. 为了保证不存在内存泄漏，可以使用free函数释放静态内存
B. 程序中不允许使用未初始化的内存变量
C. alloca函数具有很好的平台适用性，因此应该尽量使用
D. 使用负数长度去申请内存，负数会被当成一个很大的无符号整数，从而可能导致因申请内存过大而出现失败
E. 堆内存释放后可以再访问

46. 对于整数溢出问题，下面说法正确的是：ABD
A. 整型转换时避免出现截断危险
B. 有符号整数运算时，要保证结果不能出现溢出
C. 整数溢出一般只会导致逻辑错误，不会产生安全问题
D. 无符号整数运算时，要保证结果不能出现反转
47. 关于不安全函数或对象的描述，正确的是:CD
A. 应该禁止使用strcpy、strcat等不安全字符串处理函数，最好使用不存在安全风险的strncpy、strncat等带n版本函数
B. std::ostringstream的使用应该特别注意，稍不慎就可能导致内存访问越界、缓冲区溢出等问题，因此推荐使用std::ostream代替
C. system()函数和popen()函数的使用可能会导致命令注入的发生，替代方案：在windows下可以使用Win32 API CreateProcess()函数，在linux下可以使用exec()族函数。
D. 在C++程序中，应尽量使用C++标准库函数代替C的字符串操作函数
48. 下列哪些信息不可以打印到日志中：ABCD
A. 口令明文
B. 口令密文
C. 加密秘钥
D. 身份ID
49. 下列代码片断哪些不符合安全编码规范要求：ABCD
A. int id_gen() { enum {len = 12}; char id[len]; int r; int num; r = rand(); num = snprintf(id, len, "ID%-d", r); /* 生成 ID */ /* 其他处理 */ }
B. unsigned int add(unsigned int a, unsigned int b) { unsigned int sum; sum = a + b; return sum; }
C. int file_ops(char* file_name) { FILE *fp; fp = fopen(file_name, "w"); if (fp == NULL) { return -1; } /* 其他处理 */ if (fclose(fp) != 0) return -1; } if (remove(file_name) != 0) { return -1; } return 0; }
D. int foo(char* str) { size_t len = strlen(str); if (len >= MAX_BUF_SIZE - 1) { return -1; } char *buf = (char*)malloc(256); if (buf == NULL) { return -1; } strncpy(buf, str, len); /* 对 buf 的其它处理 */ free(buf); buf = NULL; }
50. （多选）关于以下宏和const用法不容易导致错误的是:ABC 
A. ④
B. ①
C. ③
D. ②
51. 为防止命令注入，可以采取下列方法：ABD
A. 对于Windows系统，建议使用Win32 API CreateProcess()等与命令解释器无关的进程创建函数来替代；
B. 在POSIX下可以使用exec系列函数。
C. 可以在exec族函数中调用\bin\sh等命令解析器。
D. 若需调用\bin\bash等命令解析器，则必须对入参进行校验，过滤其中的命令分隔符。
52. （多选）如下场景，哪些需要增加空行 BD
A. 注释行之后
B. 相对独立的程序块之间。
C. 变量声明之间。
D. 变量说明之后。
53. （多选）坚持以下哪些措施可以避免内存操作越界：ABCDE
A. 数组下标进行检查。
B. 指针加减操作时，考虑指针类型长度。
C. 字符串考虑最后的'\0'， 确保所有字符串是以'\0'结束。
D. 避免使用危险函数sprintf /vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数snprintf/strncpy/strncat/fgets代替。
E. 使用memcpy/memset时一定要确保长度不要越界。


