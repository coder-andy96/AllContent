54. 关于资源管理的说法正确的是：BCD
A. 使用malloc()函数申请内存后，必须使用free()或者delete()来释放该内存，以防止内存泄露
B. 防止资源的双重释放或者关闭。
C. 内存申请、释放应该配对存在
D. 可能造成资源泄露的资源包括但不局限于动态内存，文件句柄/描述符，数据库等。
55. 对于外部输入的参数校验，可采用的校验方式有：ABCD
A. 校验输入数据的范围
B. 输入验证前，对数据进行归一化处理以防止字符转义绕过校验
C. 校验输入数据长度
D. 输入校验应当采用"白名单"形式
56. 关于编码安全的相关内容，描述错误的是:CD
A. getenv()函数的返回指针指向值可能会被后续的getenv()调用所覆盖，或者因为调用putenv()/setenv()及其它方法修改了环境变量值而变得无效。
B. 程序员应当使用编译器的最高警告等级。在编译过程中，应该修改程序中的错误，直到警告解除。
C. strtok是一个线程不安全函数，因为它使用了动态分配的空间来存储被分割的字符串位置。
D. 多线程环境下，std::cout与printf配合使用时，必须要注意二者存在的微弱时序差别，很多问题都是由于微弱的时序差别引起的。
57. 下列关于输入校验说法错误的是：AD
A. 当程序需要用户上传文件时，严格校验用户上传的文件后缀名可以有效防止可执行文件上传漏洞。
B. 软件最为普遍的缺陷就是对来自客户端或者外部环境的数据没有进行正确的合法性校验。这种缺陷可以导致几乎所有的程序弱点。
C. 输入校验中如果没有特殊要求，应当首先考虑采用“白名单”校验形式。
D. 可以直接使用任意用户输入来构造格式化字符串，不会带来安全风险。
58. 下列说法中正确的是：ABCD
A. realloc()函数不是一个设计良好的函数。虽然在编码中提供了一些便利性，但是却极易引发各种bug，因此应该禁止使用。
B. 当为其它应用程序开发接口或者与其他团队合作开发时，正确使用const可以有效地避免数据覆写和误解。
C. 程序员必须严格的校验并合适的处理函数返回的错误值，确保函数执行成功之后再进行后续操作。
D. 解引用空指针是一种未定义的行为，而最为有效地防止空指针解引用的方法就是在指针使用前做非空校验。
59. 下列哪些代码是不安全的，可能引发溢出漏洞：ABC
A. ... struct hostent *clienthp; char hostname[MAX_LEN]; // create server socket, bind to server address and listen on socket ... // accept client connections and process requests int count = 0; for (count = 0; count < MAX_CONNECTIONS; count++) { int clientlen = sizeof(struct sockaddr_in); int clientsocket = accept(serversocket, (struct sockaddr *)&clientaddr, &clientlen); if (clientsocket >= 0) { clienthp = gethostbyaddr((char*) &clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET); strcpy(hostname, clienthp->h_name); logOutput("Accepted client connection from host ", hostname); // process client request ... close(clientsocket); } } close(serversocket); ...
B. char buf[24]; printf("Please enter your name and press <Enter>\n"); gets(buf); ... }
C. char last_name[20]; printf ("Enter your last name: "); scanf ("%s", last_name);
D. void MsgCopy() { char dst[MAX_SIZE + 1] = {0x00}; char *temp = getInputMsg(); size_t len = strlen(temp); if(len > MAX_SIZE ll NULL == temp) { return; } strcpy_s(dst, sizeof(dst), temp); }
60. （多选）恶意用户和合法用户的误用误操作都可能产生非法输入，以下哪些场景尤其需要检查用户输入？ABCDE
A. 用户输入作为循环条件
B. 用户输入作为格式化字符串
C. 用户输入作为内存分配的尺寸参数
D. 用户输入作为业务数据
E. 用户输入作为数组下标
61.下列哪个场景可能导致信息泄露？ABCD
A. 用户输入
B. 用户态输入
C. 外部调用的参数
D. 进程间的通信数据
62. 下列哪些函数是调用了系统的命令解析器的：BC
A. 以上都是
B. POSIX的popen()
C. C99的system()
D. POSIX的exec系列函数
63. 下面哪些函数使用不当极易引入命令注入漏洞：AB
A. Java代码中的Runtime.exec()函数。
B. C/C++函数system()和popen()。
C. Win32 API CreateProcess()函数。
D. POSIX下的exec系列函数。
64. （多选）关于函数设计，哪些描述是正确的？ACD
A. 重复代码应该尽可能提炼成函数。
B. 应该设计高扇出、合理扇入的函数。
C. 一个函数仅完成一件功能，不能将无关的功能置于同一函数中。
D. 函数设计的精髓：编写整洁函数，同时把代码有效组织起来。
65. （多选）如下对于头文件的描述正确的有：AC
A. 头文件应该职责单一。
B. 只要有需要，头文件之间可以循环依赖，不会有负面影响。
C. 头文件应该自包含。
D. .c文件或.h文件，可以包含自己不用的头文件，因为不会有负面影响。
46．（多选）以下描述哪些是错误的？  B不确定，但是我选了
 
47. 直接或者间接将用户输入作为格式化字符串的一部分或者全部会引发下述哪些安全问题：
 
48. 关于不安全函数或对象的描述，正确的是:
 
49. （多选）以下规则描述，正确的有：
 
50. （多选）使用宏有哪些注意事项______。
 
51. 关于防御XSS进行输入校验的描述，正确的是：
 
52. 下列哪些代码是不安全的，可能引发溢出漏洞：
 
53. 下列关于SQL注入防御的说法正确的是：
 
54. 下列代码片断哪些不符合安全编码规范要求：
 
55. 下列关于输入校验说法错误的是：
 
56. 关于编码安全的相关内容，描述错误的是:
 
57. （多选）模块a由头文件a.h和实现文件a.c组成，对于a.h中放置的内容，描述正确的是：

58. 下面哪些函数的返回值必须以int类型变量接收
 
59. 哪个场景可能导致信息泄露
 
60. 下列说法中正确的是：
 
61. 
62. 下列哪些内容可以打印到日志中
 
63. （多选）关于程序注释，哪些描述是正确的？
 
64. 对于整数溢出问题，下面说法正确的是：
 
65. 关于缓冲区溢出的描述，正确的是：
 

下列关于已释放内存的说法错误的是：
 a.一块堆内存释放、归还内存池以后，就不应该再访问，因为这块内存可能已被其它代码申请走，内容可能被修改 
 b. 函数内部局部变量的存储单元可以在栈上创建，函数执行完毕结束时这些存储单元会自动释放。因此函数执行时返回已经释放的存储单元的栈地址不会产生安全问题，因为已经自动释放置空 
 c. 直接修改已经释放的内存，可能会导致该内存功能不正常 
 d. 动态申请的内存只能释放一次，多次释放可能会导致“溢出”漏洞发

Answers of examinees：b Correct answer
questionScore:(2.0)   Current Score: 2.0 
4.Multiple Choice(Select one choice) 
下面代码片断，哪个是符合安全编程规范的：
 a.void main(int argc, char *argv[]) 
{ 
    char dst[128]; 
    if (argc &gt; 1)
    { 
        strcpy(dst, argv[1]); 
    } 
    /*…*/ 
}
 b.void  foo ()
{
 char dst[11];
 char src[] = "0123456789";
 char *tmp = NULL;
 memset(dst,'@',sizeof(dst)); 
 memcpy(dst,src, strlen(src));
 printf("src: %s \r\n", src);
 tmp = dst; 
 do
 {
  putchar(*tmp);
 }while (*tmp++); 
 return; 
 c.void  foo()
{
 char *error_msg = "Resource not available to user.";
 int error_type = 3; 
 /* ...do something... */
 printf("Error (type %s): %d\n", error_type, error_msg); 
}
 d.int * foo(int x)
{
 int i;
 int *y;
 if(0&gt; x &gt; MAX_SIZE) 
 {
  y = (int *)malloc( x * sizeof(int));
  if (y == NULL)
   return NULL;
 }
 else
 {
  return NULL;
 }
 for(i=0;i&gt;x;i++)
 {
  y[i]=i;
 }
 return y;
}
Answers of examinees：a Wrong answer，
错误解析：A：strcpy(dst,argv[1]),源字符串长度可能大于目标数组空间，造成缓冲区溢出；B：strlen()不会将’\0’结束符算入长度，配合memcpy使用时会丢失’\0’结束符。C：格式化参数类型不匹配，正确写法：printf("Error (type %s): %d\n", error_msg, error_type); 
questionScore:(2.0)   Current Score: 0.0 

5.Multiple Choice(Select one choice) 
下列代码正确的是：
 a.void func()
{
 int nresp = packet_get_int();
 if (nresp &gt; 0)
 {
  response = xmalloc(nresp * sizeof(char *));
  for (i = 0; i &lt; nresp; i++)
  { 
   response[i] = packet_get_string(NULL);
  }
 } 
} 
 b.
void func()
{
 char *request = packet_get_string();
 if (!legal_request(request)) 
 { 
  sprintf(error_msg, "Illegal request: %s", request);
  ... 
  syslog(LOG_WARNING, error_msg);
 }
} 
 c.
const int BUFFER_SIZE = 10;
void access_dbuffer(int *x, int n) 
{
 x[n-1] = 1;
}
void caller(int n) 
{
 int array[BUFFER_SIZE];
 if ((n &lt; BUFFER_SIZE) && (n &gt; 0))
 {
  access_dbuffer(array, n);
 }
}
 d.
void func()
{
 char destination_buffer[256];
 char source_buffer[1024];
 ... 
 strcpy(destination_buffer, source_buffer);
}

Answers of examinees：c Correct answer
questionScore:(2.0)   Current Score: 2.0 
6.单选题
下列说法错误的是：

 a.String street = "QueenStreet";
Query query = session.createQuery("from Address a where a.street='" + street + "'");
该代码可能会产生sql注入漏洞。
 b.
String script = System.getProperty("SCRIPTNAME");
if (script != null)
System.exec(script);
该代码可能会引起OS命令注入。

 c.
// Method called from servlet to obtain product information
public String displayProductSummary(int index) {
String productSummary = new String("");
try {
String productSummary = getProductSummary(index);
} catch (Exception ex) {...}
return productSummary;
}
public String getProductSummary(int index) {
return products[index];
}
该代码中index未校验，可能引起数组越界访问。

 d.
class DirList
{
    public static void main(String[] args)
    {
        if (args.length == 0)
        {
            System.out.println("No arguments");
            System.exit(1);
        }
        try
        {
            Runtime rt = Runtime.getRuntime();
            Process proc = rt.exec("cmd.exe /c dir " + args[0]);
            // ...
        }
        catch (Exception e)
        {
            // Handle errors
        }
    }
}
改代码可能引起命令注入。
考生答案：a 回答正确

下列代码正确的是：
 a.void func()
{
 int nresp = packet_get_int();
 if (nresp &gt; 0)
 {
  response = xmalloc(nresp * sizeof(char *));
  for (i = 0; i &lt; nresp; i++)
  { 
   response[i] = packet_get_string(NULL);
  }
 } 
} 

 b.
void func()
{
 char *request = packet_get_string();
 if (!legal_request(request)) 
 { 
  sprintf(error_msg, "Illegal request: %s", request);
  ... 
  syslog(LOG_WARNING, error_msg);
 }
} 
 c.
const int BUFFER_SIZE = 10;
void access_dbuffer(int *x, int n) 
{
 x[n-1] = 1;
}
void caller(int n) 
{
 int array[BUFFER_SIZE];
 if ((n &lt; BUFFER_SIZE) && (n &gt; 0))
 {
  access_dbuffer(array, n);
 }
}

 d.
void func()
{
 char destination_buffer[256];
 char source_buffer[1024];
 ... 
 strcpy(destination_buffer, source_buffer);
}

考生答案：c 回答正确

8.Multiple Choice(Select one choice) 
（单选）关于程序注释，哪些描述是正确的？

 a.对变量的定义和分支语句（条件分支、循环语句等）必须编写注释 
 b.重点在代码中巧妙的、晦涩的、有趣的、重要的地方加以注释 
 c.在程序块的结束行右方加注释标记，以表明某程序块的结束 
 d.注释中可以使用自定义缩略语

Answers of examinees：a Wrong answer，推荐答案：B，编程规范特意强调了不要为了写注释而写注释，而只在必要时写，也就是B所描述的情况下写。
questionScore:(2.0)   Current Score: 0.0 

9.Multiple Choice(Select one choice) 
关于SQL注入说法错误的是：
 a.所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
 b. SQL注入可以一般分为平台层注入和代码层注入。 
 c.  使用存储过程可以有效防止SQL注入。 
 d. 一个有效防止SQL注入的方法是将存储在数据库中的数据加密。

Answers of examinees：d Wrong answer，
推荐答案：C，存储过程使用动态方式构建SQL语句，导致SQL注入风险
questionScore:(2.0)   Current Score: 0.0 
10.Multiple Choice(Select one choice) 
关于文件输入/输出安全的说法错误的是
 a.不要将fgetc()等函数的返回值定义为char，因为当这些函数的返回值与EOF比较时，可能会产生问 
 b. 创建文件时需要对文件的访问权限进行显式指定，否则可能会导致未经授权用户访问该文件 
 c. 路径在校验前需要进行标准化，去除其中的干扰因素，如相对路径符号等 
 d. 访问文件时应使用明确的文件名作为输入，这样可以防止攻击者通过更改文件描述符来替换文件的目的

Answers of examinees：d Correct answer
questionScore:(2.0)   Current Score: 2.0 

11.Multiple Select (Select two or more choices) 
关于加密算法，下列说法错误的是：
 a.非常强大的私有加密算法，在产品中也可以使用 
 b. 加密算法分为对称加密算法和非对称加密算法 
 c. 基于哈希算法的口令安全存储必须加入盐值 
 d. RSA的密钥长度最低安全要求是1024位

Answers of examinees：ad Correct answer
questionScore:(2.0)   Current Score: 2.0 
12.Multiple Select (Select two or more choices) 
下面哪些函数使用不当极易引入命令注入漏洞：
 a.POSIX下的exec系列函数。 
 b. Win32 API CreateProcess()函数。 
 c. C/C++函数system()和popen()。 
 d. Java代码中的Runtime.exec()函数。

Answers of examinees：abcd Wrong answer，推荐答案：C\D
questionScore:(2.0)   Current Score: 0.0 

13.Multiple Select (Select two or more choices) 
下列哪些方式产生的随机数可用于安全用途：
 a.Unix/Linux下读取/dev/random文件 
 b. Windows使用随机数生成函数CryptGenRandom() 
 c. 使用开源组件openssl 
 d. 使用我司中研封装的iPSI组件

Answers of examinees：abd Wrong answer,
推荐答案：ABCD，Unix/Linux下采取建议读取/dev/random文件来获取真随机数。Windows推荐使用随机数生成函数CryptGenRandom()：。由于以上推荐的2种做法并不能保证主流编译环境下满足可靠性要求，对于可靠性要求很严格的产品可以使用开源组件openssl或我司中研封装的iPSI组件：
questionScore:(2.0)   Current Score: 0.0 
14.Multiple Select (Select two or more choices) 
下列代码错误的是：
 a.void* myalloc() 
{
  // do something to alloc memory
}
void myfree(void *p) 
{
  // do something to delete memory
}
void test() 
{
  void *p = myalloc();
  ...
  free(p); 
}
 b.
void func() 
{
    static char source[] = "Twenty characters!!!";
    char dest[10];
    strncpy(dest, source, strlen(source));
}
 c.
#define MAX_NRESP 256
void func()
{
 int nresp = packet_get_int();
 if (nresp &gt; 0 && nresp &lt; MAX_NRESP) 
 {
  response = xmalloc(nresp * sizeof(char *));
  for (i = 0; i &lt; nresp; i++) 
  { 
   response[i] = packet_get_string(NULL);
  }
 } 
} 
 d.
void func(char * source) 
{
 if(source == NULL)
 {
  /* handle error */
 }
 char dest[10] = {0x0};
 ...
    if(strlen(source) &lt; 10)
    {
  strncpy(dest, source, strlen(source); 
 }
}

Answers of examinees：bc Wrong answer，
推荐答案：AB；B：缓冲区太少；
questionScore:(2.0)   Current Score: 0.0 

15.Multiple Select (Select two or more choices) 
下列哪些代码的资源没有正常关闭：
 a.try {
Connection con = DriverManager.getConnection(some_connection_string);
}
catch ( Exception e ) {
log( e );
} 
 b.
...
SqlConnection conn = new SqlConnection(connString);
SqlCommand cmd = new SqlCommand(queryString);
cmd.Connection = conn;
conn.Open();
SqlDataReader rdr = cmd.ExecuteReader();
HarvestResults(rdr);
conn.Connection.Close();
... 
 c. 
class A {
void foo();
};
void A::foo(){
int *ptr;
ptr = (int*)malloc(sizeof(int));
delete ptr;
} 
 d. 
class A{
void foo(bool);
};
void A::foo(bool heap) {
int localArray[2] = {
11,22
};
int *p = localArray;
if (heap){
p = new int[2];
}
delete[] p;
}

Answers of examinees：abc Wrong answer,
推荐答案:ABCD,
A：如果在建立数据库连接和在相同连接关闭之前发生异常，数据库连接池可能会耗尽。如果超过可用连接的数量，其他用户就无法访问该资源，有效地拒绝访问该应用程序。
B：如果在执行SQL或处理结果时出现异常，则SqlConnection对象不会关闭。
C：malloc和free搭配使用，
D:new和delete针对的是堆内存的分配，如果heap是FALSE，那么就是在非堆上操作。
questionScore:(2.0)   Current Score: 0.0 
16.Multiple Select (Select two or more choices) 
下列哪个场景可能导致信息泄露？
 a.用户输入 
 b. 进程间的通信数据 
 c. 用户态输入 
 d. 外部调用的参数

Answers of examinees：bd Wrong answer，感觉答案有点问题。编程规范考试改革前的原题，答案是BD
questionScore:(2.0)   Current Score: 0.0 

17.Multiple Select (Select two or more choices) 
关于数据库操作说法正确的是：
 a.使用存储过程来执行所有的查询。 
 b. 避免出现一些详细的错误消息。 
 c. 使用专业的扫描工具来确保数据库安全。 
 d. 每个应用使用单独的权限进行数据库连接.

Answers of examinees：bcd Wrong answer，
推荐答案：ABCD，感觉答案有点问题。编程规范考试改革前的原题，答案是BCD
questionScore:(2.0)   Current Score: 0.0 
18.Multiple Select (Select two or more choices) 
以下说法正确的有：
 a.malloc分配出来的内存，可以使用memset_s进行清零 
 b.  为了保证不存在内存泄漏，可以多次释放申请的内存 
 c. 使用 0 字节长度去申请内存的行为是没有定义的，在引用内存申请函数返回的地址时会引发不可预知或不能立即发现的问题 
 d. 为了使用方便，建议使用alloca 函数申请内存 
 e. 为了保证内存空间足够，必须对指定申请内存大小的整数值进行合法性校验

Answers of examinees：ce Wrong answer,
推荐答案：ACE
questionScore:(2.0)   Current Score: 0.0 

19.Multiple Select (Select two or more choices) 
关于编码安全的相关内容，描述错误的是:
 a.getenv()函数的返回指针指向值可能会被后续的getenv()调用所覆盖，或者因为调用putenv()/setenv()及其它方法修改了环境变量值而变得无效。 
 b. 多线程环境下，std::cout与printf配合使用时，必须要注意二者存在的微弱时序差别，很多问题都是由于微弱的时序差别引起的。 
 c. strtok是一个线程不安全函数，因为它使用了动态分配的空间来存储被分割的字符串位置。 
 d. 程序员应当使用编译器的最高警告等级。在编译过程中，应该修改程序中的错误，直到警告解除。

Answers of examinees：abcd Wrong answer，
推荐答案：BC；
B：多线程环境下，禁止std::cout与printf混用，两者的混用很容易带来不可预知的错误，常见的错误有打印输出的结果不符合预期，而严重错误时甚至会导致内部缓存区溢出，导致crash。
C：因为它使用了静态分配的空间来存储被分割的字符串位置
questionScore:(2.0)   Current Score: 0.0 
20.Multiple Select (Select two or more choices) 
下列代码不符合安全编码规范的是:
 a.void Func()
{
 char dst[ARRAY_SIZE + 1];
 char src[ARRAY_SIZE + 1];
 unsigned int i = 0;
 memset(src, '@', sizeof(dst));
 for(i=0; src[i] != ’\0’ && (i &gt; sizeof(dst)); ++i )
  dst[i] = src[i];
 dst[i] = ’\0’; 
 /*…*/ 
} 
 b. void  Func()
{
 char dst[5];
 char src[] = "0123456789";
 strncpy(dst, src, sizeof(dst)); 
     printf(dst); 
 return;
} 
 c. void  Func()
{
 #define MAX_LEN 1024
 char cBuf[MAX_LEN + 1] = {0};
 int nPid = 0;
 strncpy(cBuf, ”Hello World!”, strlen(”Hello World!”));
 snprintf(cBuf, MAX_LEN, "%d: %s", nPid, cBuf); 
 return; 
} 
 d. INT32 NoCompliant(UINT32 ui1, UINT32 ui2, UINT32 * ret)
{
 if( NULL == ret )
 {
  return ERROR;
 }
 *ret = ui1 + ui2;
  return (OK);
}
Answers of examinees：abcd Correct answer
questionScore:(2.0)   Current Score: 2.0 

21.Multiple Select (Select two or more choices) 
（多选）关于程序注释，哪些描述是正确的？
 a.文件头部应进行注释 
 b.所有函数头部应该进行注释 
 c.注释越多越好 
 d.全局变量必须要有注释

Answers of examinees：abd Wrong answer，推荐答案：AD
questionScore:(2.0)   Current Score: 0.0 
24.单选题 
下述哪种代码写法是正确的：
 a.char *error_msg = "Resource not available to user.";
int error_type = 3;
printf("Error (type %s): %d\n", error_type, error_msg);
 b.printf("Error (type %s)\n");
 c.char *error_msg = "Resource not available to user.";
int error_type = 3;
printf("Error (type %d): %s\n", error_type, error_msg);
 d.char *error_msg = "Resource not available to user.";
int error_type = 3;
printf("Error (type %s): %d\n", error_type);

考生答案：d 回答错误
试题分数:(2.0)   当前得分: 0.0 

25.单选题 
下列代码正确的是：
 a.int func(int i)
{
 void *p = malloc(10);
 void *q = malloc(4);
 if(i &gt; 0)
  free(p);  
  p = q;
 else
  free(q);
 free(p);
 return 0;
}
 b.
void func(struct S *p)
{
  free(p);
  free(p-&gt;field);
} 
 c.
int func1(void *p)
{
 if(some_error())
 {
  free(p);
  return -1;
 }
 return 0;
}
void func2() 
{
 void *p = malloc(42);
 if(f(p) &lt; 0)
 {
  free(p);
 }
 use(p); 
}
 d.
int func(int *p) 
{
 int x;
 if ( p == NULL )
 {
  x = 0; 
 } 
 else 
 {
  x = *p; 
 }
 x += fn(); 
 *p = x;
 return 0; 
}

考生答案：b 回答错误
试题分数:(2.0)   当前得分: 0.0 
26.多选题 
对于如下代码，说法正确的是（        ）
void Func(char *user, char *password) 
{
    char input[1000];
    if (fgets(input, sizeof(input) - 1, stdin) == NULL) 
    {
        /* handle error */
    }
    input[sizeof(input)-1] = ’\0’;
    printf(input); 
}
 a.语句fgets(input, sizeof(input) - 1, stdin)可能会造成缓冲区溢出漏洞 
 b. 代码的input直接来自用户输入，并作为格式化字符串直接传递给printf(),可能造成格式化漏洞 
 c. 当用户输入input是“%s%s%s%s%s%s%s%s%s”，就可能触发无效指针或未映射的地址读取 
 d. 解引用空指针是一种未定义的行为，而最为有效地防止空指针解引用的方法就是在指针使用前做非空校验。

考生答案：abcd 回答错误
试题分数:(2.0)   当前得分: 0.0 

27.多选题 
下列哪个场景可能导致信息泄露？
 a.用户输入 
 b. 进程间的通信数据 
 c. 用户态输入 
 d. 外部调用的参数

考生答案：abcd 回答正确
试题分数:(2.0)   当前得分: 2.0 
28.多选题 
下列哪些代码是不安全的，可能引发溢出漏洞：
 a.void  MsgCopy()
{
    char dst[MAX_SIZE + 1] = {0x00};
    char *temp = getInputMsg();
    size_t len = strlen(temp);
    if(len &gt; MAX_SIZE  ll  NULL == temp) 
    {
        return;
    }
    strcpy_s(dst, sizeof(dst), temp);
}
 b.
char last_name[20];
printf ("Enter your last name: ");
scanf ("%s", last_name);
 c.
char buf[24];
printf("Please enter your name and press &lt;Enter&gt;\n");
gets(buf);
...
}
 d.
...
struct hostent *clienthp;
char hostname[MAX_LEN];

// create server socket, bind to server address and listen on socket
...
// accept client connections and process requests
int count = 0;
for (count = 0; count &lt; MAX_CONNECTIONS; count++) {

int clientlen = sizeof(struct sockaddr_in);
int clientsocket = accept(serversocket, (struct sockaddr *)&clientaddr, &clientlen);

if (clientsocket &gt;= 0) {
clienthp = gethostbyaddr((char*) &clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);
strcpy(hostname, clienthp-&gt;h_name);
logOutput("Accepted client connection from host ", hostname);

// process client request
...
close(clientsocket);
}
}
close(serversocket);
...

考生答案：bcd 回答正确
试题分数:(2.0)   当前得分: 2.0 


关于资源管理的说法正确的是：
 a.内存申请、释放应该配对存在 
 b. 可能造成资源泄露的资源包括但不局限于动态内存，文件句柄/描述符，数据库等。 
 c. 使用malloc()函数申请内存后，必须使用free()或者delete()来释放该内存，以防止内存泄露 
 d. 防止资源的双重释放或者关闭。

考生答案：abd 回答正确
试题分数:(2.0)   当前得分: 2.0 
30.多选题 
下列哪些代码可能会对数组产生越界访问：
 a.public String getValue(int index) {
return array[index];
}其中index来自用户输入。 
 b.
int getValueFromArray(int *array, int len, int index) {
int value;
// check that the array index is less than the maximum
// length of the array
if (index &lt; len) {

// get the value at the specified index of the array
value = array[index];
}
// if array index is invalid then output error message
// and return value indicating error
else {
printf("Value is: %d\n", array[index]);
value = -1;
}

return value;
} 
 c.
// Method called from servlet to obtain product information
public String displayProductSummary(int index) {

String productSummary = new String("");

try {
String productSummary = getProductSummary(index);

} catch (Exception ex) {...}

return productSummary;
}

public String getProductSummary(int index) {
String productSummary = "";

if ((index &gt;= 0) && (index &lt; MAX_PRODUCTS)) {
productSummary = products[index];
}
else {
System.err.println("index is out of bounds");
throw new IndexOutOfBoundsException();
}

return productSummary;
} 
 d. 
int main (int argc, char **argv) {
char *items[] = {"boat", "car", "truck", "train"};
int index = GetUntrustedOffset();
printf("You selected %s\n", items[index-1]);
}

考生答案：abcd 回答错误
试题分数:(2.0)   当前得分: 0.0 

31.多选题 
（多选）下列说法正确的是______。
 a.常量建议使用const定义代替宏
 b.除了0这样的特殊常量之外，不允许显示使用魔鬼数字。
 c.为了不使用魔鬼数字，可以定义这样的宏： #define TEN (10)
 d.对于广泛使用的数字，必须定义const全局变量/宏；同样变量/宏命名应是自注释的。

考生答案：abd 回答正确
试题分数:(2.0)   当前得分: 2.0 
32.多选题 
（多选）关于程序注释，哪些描述是正确的？
 a.修改代码同时修改相应的注释，以保证注释与代码的一致性 
 b.错误的注释不但无益反而有害 
 c.即使认为注释错误，也不能轻易删除 
 d.变量、常量、宏的注释应放在其上方相邻位置或右方

考生答案：abd 回答正确
试题分数:(2.0)   当前得分: 2.0 

33.多选题
（多选）如果a.c只对外提供一个void bar()函数作为接口，而bar函数的实现部分需要使用b.c中的void foo()函数，以下做法中错误的是：
 a.在b.c中声明extern void foo()，在a.c中声明extern void foo()。
 b. 在b.h中声明extern void foo()，在a.c中声明extern void foo()。
 c. 在b.h中声明extern void foo()，在a.c中#include b.h。
 d.在b.h中声明extern void foo()，在a.h中#include b.h。

考生答案：abd 回答正确

34.多选题 
（多选）下面说法正确的是
 a.修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性 
 b.源程序中关系较为紧密的代码应尽可能相邻 
 c.统一的调测信息格式便于集成测试 
 d.不要将边界不明确的字符串写到固定长度的数组中 
 e.将用户输入作为格式化字符串的一部分或者全部

考生答案：abcd 回答正确
试题分数:(2.0)   当前得分: 2.0 
36.多选题 
（多选）关于以下宏和const用法不容易导致错误的是: 
 a.①
 b.②
 c.③
 d.④

考生答案：cd 回答错误
考生答案：bd 回答错误

37.多选题
（多选）如下对于头文件的描述正确的有：
 a.头文件应该自包含。
 b. 头文件应该职责单一。
 c.只要有需要，头文件之间可以循环依赖，不会有负面影响。
 d..c文件或.h文件，可以包含自己不用的头文件，因为不会有负面影响。
考生答案：ab 回答正确



其他
字符串操作安全：
strncpy、strncat等带n版本的字符串操作函数容易产生结束符丢失问题
来自fgets(), getenv()的字符串在复制之前，应该获取并检查其数据长度，fgets()/getenv()获取的内容都是不可信的，因此需要添加校验
环境变量来自计算机内部，其安全性是是不可预测的，所以应该添加校验 
当源内存和目标内存存在重叠时，strcpy会出现错误，而memcpy_s不能操作重叠内存，memmove_s可以。
差一错误：
未考虑’\0’结束符写入数组的位置，添加结束符时可能导致写溢出
• 差一错误往往是由于程序员的不细心导致的，在对字符串的边界（比如字符串的最后一个字节和’\0’结束符）进行操作时要尤为小心。 
• 了解sizeof和strlen的用法和区别。
• sizeof不等同于strlen：p为局部数组变量时，sizeof(p)为数组的字节长度；
• p作为指针参数传参时，sizeof(p)为指针的字节长度：4；
strlen只能用char*类型做参数，且必须是以‘/0’结尾的，strlen将返回它的长度，但是不包括‘/0’
格式化字符串：
禁止将用户输入作为格式化字符串的一部分或全部；
否则，用户输入非法字符或字符串时，可导致程序崩溃、甚至执行任意代码。
整数运算：
整数运算时可能出现反转或溢出
内存分配：
realloc()是一个非常特殊的函数，其原型如下：
void *realloc(void *ptr, size_t size)
随着参数的不同，其行为也是不同。
当ptr与size均不为NULL时，该函数会重新调整内存大小，并将新的内存指针返回，并保证最小的size的内容不变；
参数ptr为NULL，但size不为0，那么行为等同于malloc(size)；
参数size为0，则realloc的行为等同于free(ptr)。
由此可见，一个简单的C函数，却被赋予了3种行为，这不是一个设计良好的函数。我司禁止使用这个函数。
对于malloc函数申请动态内存的说明：
使用 0 字节长度去申请内存的行为是没有定义的，在引用内存申请函数返回的地址时会引发不可预知或不能立即发现的问题
动态申请操作应和释放操作配合使用，防止内存泄露
使用负数长度去申请内存，负数会被当成一个很大的无符号整数，从而导致因申请内存过大而出现失败
动态申请内存被释放2次，会造成安全问题
文件操作：
关于文件输入/输出安全的说明：
不要将fgetc()等函数的返回值定义为char，因为当这些函数的返回值与EOF比较时，可能会产生问题
创建文件时需要对文件的访问权限进行显式指定，否则可能会导致未经授权用户访问该文件
路径在校验前需要进行标准化，去除其中的干扰因素，如相对路径符号等
标准化校验文件的路径是为了去除其中的非法符号，将路径转为绝对路径。
cout与printf的说明：
两者的缓冲区机制不同（printf无缓冲区，而std::cout有），而且对于标准输出的加锁时机也略有不同
printf: 在对标准输出作任何处理前先加锁；
std::cout: 在实际向标准输出打印时方才加锁。
二者存在微弱的时序差别，而多线程环境下，很多问题就是由于微弱的时序差别造成的。所以两者的混用很容易带来不可预知的错误，常见的错误有打印输出的结果不符合预期，而严重错误时甚至会导致内部缓存区溢出，导致crash。
在多线程环境下，禁止混合使用cout和printf
产生随机数的说明：
下列方式产生的随机数可用于安全用途：
Unix/Linux下读取/dev/random文件
Windows使用随机数生成函数CryptGenRandom()
使用开源组件openssl
使用我司中研封装的iPSI组件
安全用途的随机数使用必须使用安全随机数。禁用rand(),random(),/dev/random()
